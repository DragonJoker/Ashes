#include "GlRendererPrerequisites.hpp"

namespace ashes::gl
{
	std::string getName( GlQueryType value )
	{
		switch ( value )
		{
		case GL_QUERY_TYPE_SAMPLES_PASSED:
			return "GL_SAMPLES_PASSED";
		case GL_QUERY_TYPE_TIMESTAMP:
			return "GL_TIMESTAMP";
		case GL_QUERY_TYPE_PRIMITIVES_GENERATED:
			return "GL_PRIMITIVES_GENERATED";
		case GL_QUERY_TYPE_VERTICES_SUBMITTED:
			return "GL_VERTICES_SUBMITTED";
		case GL_QUERY_TYPE_PRIMITIVES_SUBMITTED:
			return "GL_PRIMITIVES_SUBMITTED";
		case GL_QUERY_TYPE_VERTEX_SHADER_INVOCATIONS:
			return "GL_VERTEX_SHADER_INVOCATIONS";
		case GL_QUERY_TYPE_TESS_CONTROL_SHADER_PATCHES:
			return "GL_TESS_CONTROL_SHADER_PATCHES";
		case GL_QUERY_TYPE_TESS_EVALUATION_SHADER_INVOCATIONS:
			return "GL_TESS_EVALUATION_SHADER_INVOCATIONS";
		case GL_QUERY_TYPE_GEOMETRY_SHADER_INVOCATIONS:
			return "GL_GEOMETRY_SHADER_INVOCATIONS";
		case GL_QUERY_TYPE_GEOMETRY_SHADER_PRIMITIVES_EMITTED:
			return "GL_GEOMETRY_SHADER_PRIMITIVES_EMITTED";
		case GL_QUERY_TYPE_FRAGMENT_SHADER_INVOCATIONS:
			return "GL_FRAGMENT_SHADER_INVOCATIONS";
		case GL_QUERY_TYPE_COMPUTE_SHADER_INVOCATIONS:
			return "GL_COMPUTE_SHADER_INVOCATIONS";
		case GL_QUERY_TYPE_CLIPPING_INPUT_PRIMITIVES:
			return "GL_CLIPPING_INPUT_PRIMITIVES";
		case GL_QUERY_TYPE_CLIPPING_OUTPUT_PRIMITIVES:
			return "GL_CLIPPING_OUTPUT_PRIMITIVES";

		default:
			assert( false && "Unsupported GlQueryType" );
			return "GL_QUERY_TYPE_UNKNOWN";
		}
	}

	GlQueryType convert( VkQueryType const & value )
	{
		switch ( value )
		{
		case VK_QUERY_TYPE_OCCLUSION:
			return GL_QUERY_TYPE_SAMPLES_PASSED;
		case VK_QUERY_TYPE_TIMESTAMP:
			return GL_QUERY_TYPE_TIMESTAMP;
		case VK_QUERY_TYPE_PIPELINE_STATISTICS:
			return GL_QUERY_TYPE_PRIMITIVES_GENERATED;
		default:
			assert( false && "Unsupported query type" );
			return GL_QUERY_TYPE_TIMESTAMP;
		}
	}

	std::vector< GlQueryType > getQueryTypes( VkQueryPipelineStatisticFlags value )
	{
		std::vector< GlQueryType > result;

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_VERTICES_SUBMITTED );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_PRIMITIVES_SUBMITTED );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_VERTEX_SHADER_INVOCATIONS );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_GEOMETRY_SHADER_INVOCATIONS );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_GEOMETRY_SHADER_PRIMITIVES_EMITTED );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_CLIPPING_INPUT_PRIMITIVES );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_CLIPPING_OUTPUT_PRIMITIVES );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_FRAGMENT_SHADER_INVOCATIONS );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_TESS_CONTROL_SHADER_PATCHES );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_TESS_EVALUATION_SHADER_INVOCATIONS );
		}

		if ( checkFlag( value, VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT ) )
		{
			result.push_back( GL_QUERY_TYPE_COMPUTE_SHADER_INVOCATIONS );
		}

		return result;
	}
}
